#!/usr/bin/env python3
"""
Appify 2.0.3 - Smart Browser Detection Edition
- INTELLIGENT BROWSER DETECTION: Auto-detects native vs Flatpak installations
- WAYLAND/X11 NATIVE SUPPORT: Automatically configures for your display server
- DEFAULT BROWSER DETECTION: Uses your system's default browser
- 8 Browsers fully supported: Firefox, Edge, Brave, Vivaldi, Chrome, Chromium, Opera, Ungoogled Chromium
- Enhanced WebHID with full UI control for cloud gaming
- Auto icon download
- Extension presets with verified working URLs
- Kiosk, GPU, nice/ionice optimization
- Dark mode
- Full logging
- Linux-first design with smart detection
"""

# Appify
# Copyright (C) 2025 Bobby Comet
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Gio, GLib, Gdk, Adw
import os
import re
import sys
import json
import shutil
import argparse
import subprocess
import tempfile
import shlex
import threading
from urllib.parse import urlparse
from pathlib import Path
import requests 
from packaging.version import Version 
import locale
import gettext

CURRENT_VERSION = "2.0.3"

# ---------------- Internationalization (i18n) ----------------

def setup_i18n():
    """
    Detects the system language and loads a matching appify.mo translation file.
    Searches all standard locale directories used across Linux distros:
      - Debian/Ubuntu:        /usr/share/locale/
      - Arch Linux:           /usr/share/locale/
      - Fedora/RHEL:          /usr/share/locale/
      - AppImage (bundled):   $APPDIR/usr/share/locale/
      - User-local override:  ~/.local/share/locale/
      - Next to this script:  ./locale/  (dev/testing)

    If no .mo file is found for the detected language, silently falls back
    to English (identity function) — no errors, no crashes.

    To add a translation:
      1. Extract strings:  xgettext -L Python -o appify.pot Appify.py
      2. Create .po:       msginit -l de_DE -o locale/de_DE/LC_MESSAGES/appify.po
      3. Compile .mo:      msgfmt locale/de_DE/LC_MESSAGES/appify.po -o locale/de_DE/LC_MESSAGES/appify.mo
      4. Install .mo to:   /usr/share/locale/de_DE/LC_MESSAGES/appify.mo
    """
    lang = (
        os.environ.get("LC_ALL")
        or os.environ.get("LANGUAGE")
        or os.environ.get("LANG")
        or ""
    ).split(".")[0].split(":")[0]

    if not lang or lang.lower().startswith("c") or lang.lower() == "posix":
        return lambda s: s

    search_dirs = []
    search_dirs.append(Path.home() / ".local" / "share" / "locale")

    appdir = os.environ.get("APPDIR")
    if appdir:
        search_dirs.append(Path(appdir) / "usr" / "share" / "locale")

    for p in [
        "/usr/share/locale",
        "/usr/local/share/locale",
        "/var/lib/flatpak/exports/share/locale",
        "/snap/core/current/usr/share/locale",
    ]:
        search_dirs.append(Path(p))

    search_dirs.append(Path(__file__).parent / "locale")

    lang_variants = [lang]
    if "_" in lang:
        lang_variants.append(lang.split("_")[0])

    for locale_dir in search_dirs:
        for lang_code in lang_variants:
            mo_path = locale_dir / lang_code / "LC_MESSAGES" / "appify.mo"
            if mo_path.exists():
                try:
                    translation = gettext.translation(
                        domain="appify",
                        localedir=str(locale_dir),
                        languages=[lang_code],
                        fallback=False,
                    )
                    print(f"[Appify] Loaded translation: {mo_path}")
                    return translation.gettext
                except Exception as e:
                    print(f"[Appify] Translation load failed ({mo_path}): {e}")
                    continue

    return lambda s: s

_ = setup_i18n()

# ---------------- Browser Detection System ----------------

def is_wayland_session() -> bool:
    """Detects if the current session is Wayland"""
    return bool(os.environ.get('WAYLAND_DISPLAY'))

def is_x11_session() -> bool:
    """Detects if the current session is X11"""
    return bool(os.environ.get('DISPLAY')) and not is_wayland_session()

def get_session_type() -> str:
    """Returns 'wayland', 'x11', or 'unknown'"""
    if is_wayland_session():
        return "wayland"
    elif is_x11_session():
        return "x11"
    return "unknown"

def get_display_backend_flags(browser_key: str = "") -> str:
    """Returns appropriate display backend flags for current session and browser"""
    session = get_session_type()
    
    # Chromium-based browsers get Wayland optimization
    chromium_browsers = ["edge", "brave", "vivaldi", "chrome", "chromium", "opera", "ungoogled-chromium"]
    
    if session == "wayland" and browser_key.lower() in chromium_browsers:
        return "--ozone-platform=wayland --enable-features=UseOzonePlatform,WaylandWindowDecorations"
    elif session == "x11":
        return ""  # Native X11, no flags needed
    else:
        # Fallback: let browser auto-detect
        return "--ozone-platform-hint=auto"

def detect_browser_installation(browser_key: str) -> dict:
    """
    Detects how a browser is installed and returns installation info.
    Returns: {
        'type': 'native' | 'flatpak' | 'snap' | 'not_found',
        'cmd': actual command to use,
        'display_name': human-readable name
    }
    """
    browsers_info = {
        "firefox": {
            "native_cmds": ["firefox", "/usr/bin/firefox"],
            "flatpak": "org.mozilla.firefox",
            "snap": "firefox",
            "name": "Firefox"
        },
        "edge": {
            "native_cmds": ["microsoft-edge", "microsoft-edge-stable"],
            "flatpak": "com.microsoft.Edge",
            "snap": "microsoft-edge",
            "name": "Microsoft Edge"
        },
        "brave": {
            "native_cmds": ["brave-browser-stable", "brave-browser", "brave"],
            "flatpak": "com.brave.Browser",
            "snap": "brave",
            "name": "Brave"
        },
        "vivaldi": {
            "native_cmds": ["vivaldi", "vivaldi-stable"],
            "flatpak": "com.vivaldi.Vivaldi",
            "snap": "vivaldi",
            "name": "Vivaldi"
        },
        "chrome": {
            "native_cmds": ["google-chrome", "google-chrome-stable"],
            "flatpak": "com.google.Chrome",
            "snap": "google-chrome",
            "name": "Google Chrome"
        },
        "chromium": {
            "native_cmds": ["chromium", "chromium-browser"],
            "flatpak": "org.chromium.Chromium",
            "snap": "chromium",
            "name": "Chromium"
        },
        "opera": {
            "native_cmds": ["opera", "opera-stable"],
            "flatpak": "com.opera.Opera",
            "snap": "opera",
            "name": "Opera"
        },
        "ungoogled-chromium": {
            "native_cmds": ["ungoogled-chromium"],
            "flatpak": None,
            "snap": None,
            "name": "Ungoogled Chromium"
        }
    }
    
    if browser_key not in browsers_info:
        return {'type': 'not_found', 'cmd': '', 'display_name': browser_key}
    
    info = browsers_info[browser_key]
    
    # Check native installation first
    for cmd in info["native_cmds"]:
        if shutil.which(cmd):
            return {
                'type': 'native',
                'cmd': cmd,
                'display_name': f"{info['name']} (Native)"
            }
    
    # Check Flatpak
    if info.get("flatpak"):
        try:
            result = subprocess.run(
                ["flatpak", "info", info["flatpak"]], 
                capture_output=True, 
                text=True,
                timeout=2
            )
            if result.returncode == 0:
                return {
                    'type': 'flatpak',
                    'cmd': f"flatpak run {info['flatpak']}",
                    'flatpak_id': info['flatpak'],
                    'display_name': f"{info['name']} (Flatpak)"
                }
        except Exception:
            pass
    
    # Check Snap
    if info.get("snap"):
        try:
            result = subprocess.run(
                ["snap", "list", info["snap"]], 
                capture_output=True, 
                text=True,
                timeout=2
            )
            if result.returncode == 0:
                return {
                    'type': 'snap',
                    'cmd': f"snap run {info['snap']}",
                    'display_name': f"{info['name']} (Snap)"
                }
        except Exception:
            pass
    
    return {
        'type': 'not_found',
        'cmd': '',
        'display_name': f"{info['name']} (Not Installed)"
    }


def get_default_browser() -> str:
    """
    Detects the system's default browser.
    Returns browser key like 'firefox', 'chrome', etc.
    """
    try:
        # Try xdg-settings first (most reliable)
        result = subprocess.run(
            ["xdg-settings", "get", "default-web-browser"],
            capture_output=True,
            text=True,
            timeout=2
        )
        if result.returncode == 0:
            desktop_file = result.stdout.strip().lower()
            
            # Map desktop file names to our browser keys
            # Handles both simple names and reverse domain notation (com.company.App.desktop)
            browser_map = {
                # Firefox variants
                'firefox': 'firefox',
                'org.mozilla.firefox': 'firefox',
                
                # Edge variants
                'microsoft-edge': 'edge',
                'com.microsoft.edge': 'edge',
                'msedge': 'edge',
                'edge': 'edge',
                
                # Brave variants
                'brave': 'brave',
                'brave-browser': 'brave',
                'com.brave.browser': 'brave',
                
                # Vivaldi variants
                'vivaldi': 'vivaldi',
                'com.vivaldi.vivaldi': 'vivaldi',
                
                # Chrome variants
                'google-chrome': 'chrome',
                'com.google.chrome': 'chrome',
                'chrome': 'chrome',
                
                # Chromium variants
                'chromium': 'chromium',
                'chromium-browser': 'chromium',
                'org.chromium.chromium': 'chromium',
                
                # Opera variants
                'opera': 'opera',
                'com.opera.opera': 'opera',
            }
            
            # First try exact match (without .desktop extension)
            desktop_name = desktop_file.replace('.desktop', '')
            if desktop_name in browser_map:
                return browser_map[desktop_name]
            
            # Then try substring matching
            for key, browser_key in browser_map.items():
                if key in desktop_file:
                    return browser_key
    except Exception:
        pass
    
    # Try alternative method: check mimeapps.list
    try:
        mimeapps_paths = [
            Path.home() / '.config/mimeapps.list',
            Path.home() / '.local/share/applications/mimeapps.list',
            Path('/etc/xdg/mimeapps.list'),
        ]
        
        for mimeapps_path in mimeapps_paths:
            if mimeapps_path.exists():
                with open(mimeapps_path, 'r') as f:
                    content = f.read().lower()
                    
                    # Look for text/html or x-scheme-handler/http handlers
                    browser_patterns = {
                        'com.microsoft.edge': 'edge',
                        'microsoft-edge': 'edge',
                        'msedge': 'edge',
                        'edge': 'edge',
                        'org.mozilla.firefox': 'firefox',
                        'firefox': 'firefox',
                        'com.brave.browser': 'brave',
                        'brave': 'brave',
                        'com.google.chrome': 'chrome',
                        'google-chrome': 'chrome',
                        'chrome': 'chrome',
                        'org.chromium.chromium': 'chromium',
                        'chromium': 'chromium',
                        'com.vivaldi.vivaldi': 'vivaldi',
                        'vivaldi': 'vivaldi',
                        'com.opera.opera': 'opera',
                        'opera': 'opera',
                    }
                    
                    # Check for text/html association
                    for pattern, browser_key in browser_patterns.items():
                        if f'text/html={pattern}' in content or f'x-scheme-handler/http={pattern}' in content:
                            return browser_key
    except Exception:
        pass
    
    # Try gio (GNOME/GTK default handler)
    try:
        result = subprocess.run(
            ["gio", "mime", "x-scheme-handler/http"],
            capture_output=True,
            text=True,
            timeout=2
        )
        if result.returncode == 0:
            desktop_file = result.stdout.strip().lower()
            
            browser_map = {
                'com.microsoft.edge': 'edge',
                'microsoft-edge': 'edge',
                'org.mozilla.firefox': 'firefox',
                'firefox': 'firefox',
                'com.brave.browser': 'brave',
                'brave': 'brave',
                'com.google.chrome': 'chrome',
                'google-chrome': 'chrome',
                'org.chromium.chromium': 'chromium',
                'chromium': 'chromium',
                'com.vivaldi.vivaldi': 'vivaldi',
                'vivaldi': 'vivaldi',
                'com.opera.opera': 'opera',
                'opera': 'opera',
            }
            
            for key, browser_key in browser_map.items():
                if key in desktop_file:
                    return browser_key
    except Exception:
        pass
    
    # Fallback: Return the first INSTALLED browser from this priority list
    # This ensures we don't default to Firefox if it's not even installed
    priority_order = ['edge', 'firefox', 'chrome', 'brave', 'chromium', 'vivaldi', 'opera']
    for browser in priority_order:
        detection = detect_browser_installation(browser)
        if detection['type'] != 'not_found':
            return browser
    
    # Ultimate fallback - only if no browsers found at all
    return 'firefox'

def scan_available_browsers() -> dict:
    """
    Scans system for all available browsers.
    Returns dict mapping browser_key to detection info.
    """
    browsers = {}
    for browser_key in ["firefox", "edge", "brave", "vivaldi", "chrome", "chromium", "opera", "ungoogled-chromium"]:
        detection = detect_browser_installation(browser_key)
        if detection['type'] != 'not_found':
            browsers[browser_key] = detection
    return browsers

# ---------------- Utilities ----------------

def slugify(text: str) -> str:
    """Converts a string to a URL-friendly slug."""
    return re.sub(r"[^a-z0-9]+", "-", text.lower()).strip("-")

def get_browsers():
    """Returns the browser configuration dictionary."""
    return CONFIG.get("browsers", DEFAULT_CONFIG["browsers"])

def get_profile_dir(app: dict) -> Path:
    """Calculates the PWA's isolated profile directory path."""
    app_name = app.get("name", "untitled")
    return CONFIG_DIR / "profiles" / slugify(app_name)

def profile_config_path(app: dict) -> Path:
    """Calculates the path to the profile's config file."""
    return get_profile_dir(app) / "profile.json"

def load_profile_config(app: dict) -> dict:
    """Loads the config for a specific PWA profile."""
    p = profile_config_path(app)
    if p.exists():
        try:
            return json.loads(p.read_text())
        except Exception:
            return {}
    return {}

def save_profile_config(app: dict, data: dict):
    """Saves the config for a specific PWA profile."""
    pd = get_profile_dir(app)
    pd.mkdir(parents=True, exist_ok=True)
    profile_config_path(app).write_text(json.dumps(data, indent=2))

def get_hostname_from_url(url: str) -> str:
    """Extracts the clean hostname from a URL."""
    try:
        parsed = urlparse(url)
        hostname = parsed.netloc or parsed.path
        return hostname.replace('www.', '').split('/')[0].split(':')[0]
    except Exception:
        return ""

def check_for_updates(callback):
    """Check GitHub for newer release in a thread, then call callback with message or None."""
    def _check():
        try:
            response = requests.get("https://api.github.com/repos/bobbycomet/Appify/releases/latest", timeout=8)
            if response.status_code != 200:
                return

            data = response.json()
            if data.get("prerelease"):
                return

            latest_tag = data["tag_name"].lstrip("v")
            latest_version = Version(latest_tag)
            current_version = Version(CURRENT_VERSION)

            if latest_version > current_version:
                msg = f"New version available: {data['tag_name']}!\nDownload from GitHub Releases."
                GLib.idle_add(callback, msg)

        except Exception as e:
            print(f"Update check failed: {e}")

    threading.Thread(target=_check, daemon=True).start()

# ---------------- Extension Helpers ----------------

def get_app_key(app):
    hostname = get_hostname_from_url(app.get("url", ""))
    for domain_substring, preset_key in PRESET_DOMAIN_MAP.items():
        if domain_substring in hostname:
            return preset_key
    return "generic_pwa"

def get_available_presets(app):
    """Returns a list of extensions available for the current app that are not yet installed."""
    preset_key = get_app_key(app)
    if not preset_key: 
        return []
    
    all_presets = DEFAULT_EXT_PRESETS.get(preset_key, [])
    installed_exts = load_installed_extensions(app)
    installed_names = {ext["name"] for ext in installed_exts}
    
    available_presets = [
        preset for preset in all_presets 
        if preset["name"] not in installed_names
    ]
    
    return available_presets

def load_installed_extensions(app):
    if not app:
        return []
    profile_cfg = load_profile_config(app)
    return profile_cfg.get("extensions", [])

def save_installed_extensions(app, exts):
    profile_cfg = load_profile_config(app)
    profile_cfg["extensions"] = exts
    save_profile_config(app, profile_cfg)

def get_icon_path(app: dict) -> Path:
    """Calculates the path to the PWA's icon file."""
    return ICON_DIR / f"{slugify(app['name'])}.png"

def get_desktop_file_path(app: dict) -> Path:
    """Calculates the path to the PWA's desktop file."""
    return DESKTOP_DIR / f"pwa-{slugify(app['name'])}-manager.desktop"

def download_file(url: str, path: Path, timeout: int = 10):
    """Downloads a file using curl."""
    try:
        subprocess.run(["curl", "-fLs", "-o", str(path), url], check=True, timeout=timeout)
        return True
    except Exception:
        return False

def download_icon(app: dict, status_callback=None):
    """Attempts to download an icon for the PWA."""
    hostname = get_hostname_from_url(app['url'])
    if not hostname:
        if status_callback: status_callback("Failed to parse hostname")
        return
    icon_path = get_icon_path(app)
    ICON_DIR.mkdir(parents=True, exist_ok=True)
    
    if download_file(f"https://icon.horse/icon/{hostname}?size=large", icon_path):
        if status_callback: status_callback(f"Icon: {hostname}")
        return
    if download_file(f"https://www.google.com/s2/favicons?domain={hostname}&sz=256", icon_path):
        if status_callback: status_callback(f"Fallback icon: {hostname}")
        return

    parsed = urlparse(app['url'])
    base_url = f"{parsed.scheme}://{parsed.netloc}"
    if download_file(f"{base_url}/favicon.ico", icon_path, timeout=8):
        if status_callback: status_callback(f"Icon from {hostname}/favicon.ico")
        return
    else:
        if status_callback: status_callback("Icon download failed")

def make_launcher_wrapper(app: dict, browser_key: str, nice: int, ionice: int, gpu: bool) -> Path:
    """
    Create a shell wrapper for launching PWAs with proper nice/ionice priority settings.
    Enhanced with full WebHID support and intelligent Wayland/X11 detection.
    """
    slug = slugify(app['name'])
    scripts_dir = CONFIG_DIR / "scripts"
    scripts_dir.mkdir(parents=True, exist_ok=True)
    wrapper = scripts_dir / f"pwa-launch-{slug}.sh"
    profile_dir = get_profile_dir(app)
    profile_dir.mkdir(parents=True, exist_ok=True)

    browser_cfg = get_browsers().get(browser_key, {})
    browser_detection = detect_browser_installation(browser_key)
    
    if browser_detection['type'] == 'not_found':
        print(f"WARNING: Browser {browser_key} not found")
        return wrapper

    kiosk_flag = browser_cfg.get('kiosk_flag', '') if app.get('kiosk', False) else ''
    args_data = browser_cfg.get('args', '{profile_dir} {url}')
    args_template = ' '.join(args_data) if isinstance(args_data, list) else str(args_data)
    app_url = app.get('url', '')
    
    unique_wm_class = f"PWA-{slug}"
    chromium_based = browser_key.lower() in ["edge", "brave", "vivaldi", "chrome", "chromium", "opera", "ungoogled-chromium"]
    
    if chromium_based:
        wm_class_arg = f"--class={unique_wm_class} --name={unique_wm_class}"
    else:
        wm_class_arg = ""

    args = args_template.format(
        profile_dir=str(profile_dir), 
        url=app_url, 
        kiosk_flag=kiosk_flag
    )

    # === ENHANCED GAMEPAD / WebHID SUPPORT + WAYLAND/X11 ===
    extra_args = ""
    if chromium_based:
        display_flags = get_display_backend_flags(browser_key)
        
        if app.get("gamepad", False):
            # Pull WebHID flags from the browser config (where they are defined),
            # falling back to sensible defaults if missing
            cfg_extra = browser_cfg.get("extra_flags", "").strip()
            if not cfg_extra:
                cfg_extra = (
                    "--enable-features=WebHID"
                    " --enable-gamepad-button-axis-events"
                    " --disable-features=WebHidBlocklist"
                )
            extra_flags = f"{cfg_extra} {display_flags}".strip()
        else:
            extra_flags = display_flags
            
        if extra_flags.strip():
            extra_args = f" {extra_flags.strip()}"
    
    if not gpu:
        extra_args += " --disable-gpu"
        
    args += extra_args

    # Build command based on installation type
    if browser_detection['type'] == 'flatpak':
        flatpak_id = browser_detection.get('flatpak_id', '')
        exec_cmd = f"$NICE_CMD $IONICE_CMD flatpak run {flatpak_id} {args} {wm_class_arg}"
    elif browser_detection['type'] == 'snap':
        snap_name = browser_key  # Snap names usually match our keys
        exec_cmd = f"$NICE_CMD $IONICE_CMD snap run {snap_name} {args} {wm_class_arg}"
    else:  # native
        cmd = browser_detection['cmd']
        
        # Special handling for Firefox kiosk mode
        if browser_key == "firefox" and app.get('kiosk', False):
            session_type = get_session_type()
            # On X11 force the GTK backend so Firefox kiosk fills the screen
            # correctly.  On Wayland Firefox handles kiosk natively - no backend
            # override is needed and passing GDK_BACKEND=x11 would actually
            # prevent it from launching.
            # env_prefix uses the POSIX `env VAR=val cmd` form so that the
            # variable is set in the child's environment rather than being
            # passed as a literal argument to setsid.
            if session_type == "x11":
                env_prefix = "env GDK_BACKEND=x11"
            else:
                env_prefix = "env"

            cmd_esc = cmd.replace('"', '\\"')

            lines = [
                '#!/usr/bin/env bash',
                '# Generated by Appify – Firefox kiosk mode',
                'set -euo pipefail',
                'source "$HOME/.profile" 2>/dev/null || true',
                '',
                f'CONFIG_DIR="{CONFIG_DIR}"',
                f'LOG_FILE="{LOG_FILE}"',
                'exec 2>>"$LOG_FILE"',
                'set -x',
                '',
                f'NICE_CMD="nice -n {nice}"',
                f'IONICE_CMD="ionice -c {ionice}"',
                f'PROFILE_DIR="{profile_dir}"',
                f'URL="{app_url}"',
                f'export GTK_APPLICATION_ID="{unique_wm_class}"',
                '',
                f'exec setsid $NICE_CMD $IONICE_CMD {env_prefix} "{cmd_esc}" \\',
                '  --profile="$PROFILE_DIR" \\',
                '  --no-remote \\',
                '  --kiosk \\',
                '  "$URL"',
            ]
            wrapper_content = '\n'.join(lines)
            wrapper.write_text(wrapper_content)
            wrapper.chmod(0o755)
            return wrapper

        cmd_esc = cmd.replace('"', '\\"')
        exec_cmd = f'$NICE_CMD $IONICE_CMD "{cmd_esc}" {args} {wm_class_arg}'

    # Session info for debugging
    session_type = get_session_type()
    
    lines = [
        '#!/usr/bin/env bash',
        '# Generated by PWA Manager',
        f'# Session: {session_type}',
        f'# Browser: {browser_detection["display_name"]}',
        'set -euo pipefail',
        'source "$HOME/.profile" 2>/dev/null || true',
        '',
        f'CONFIG_DIR="{CONFIG_DIR}"',
        f'LOG_FILE="{LOG_FILE}"',
        'exec 2>>"$LOG_FILE"', 
        'set -x', 
        '',
        f'NICE_CMD="nice -n {nice}"',
        f'IONICE_CMD="ionice -c {ionice}"',
        f'export GTK_APPLICATION_ID="{unique_wm_class}"',
        f"exec setsid {exec_cmd}",
    ]
    
    wrapper_content = '\n'.join(lines)
    
    try:
        wrapper.write_text(wrapper_content)
        wrapper.chmod(0o755)
    except Exception as e:
        print(f"Error writing wrapper script: {e}")

    return wrapper

def create_desktop_file(app: dict, script_path: str, status_callback=None):
    desktop_path = get_desktop_file_path(app)
    icon_path = get_icon_path(app)
    app_name = app["name"]
    slug = slugify(app_name)

    profile_cfg = load_profile_config(app)
    browser_key = (profile_cfg.get('browser') or app.get('browser') or CONFIG.get('browser', 'firefox')).lower()

    nice_val = CONFIG.get('nice', 0)
    ionice_val = CONFIG.get('ionice', 2)
    gpu = CONFIG.get('gpu', True)
    wrapper = make_launcher_wrapper(app, browser_key, nice_val, ionice_val, gpu)

    browser_detection = detect_browser_installation(browser_key)
    try_exec = browser_detection.get('cmd', '').split()[0] if browser_detection['type'] != 'not_found' else str(wrapper)

    unique_wm_class = f"PWA-{slug}"
    dbus_name = f"com.pwa.{slug}"

    desktop_content = f"""[Desktop Entry]
Version=1.0
Type=Application
Name={app_name}
Exec={str(wrapper)}
TryExec={try_exec}
Icon={icon_path}
Terminal=false
Categories=Network;WebBrowser;
StartupNotify=true
X-GNOME-FullName={app_name} PWA
StartupWMClass={unique_wm_class}
X-DBus-Name={dbus_name}
"""

    try:
        DESKTOP_DIR.mkdir(parents=True, exist_ok=True)
        desktop_path.write_text(desktop_content)
        desktop_path.chmod(0o755)
        subprocess.run(["update-desktop-database", str(DESKTOP_DIR)], check=False)
        if status_callback:
            status_callback(f"Desktop: {app_name}")
    except Exception as e:
        if status_callback:
            status_callback(f"Desktop failed: {e}")

def save_config():
    """Writes the current CONFIG dictionary to the config file."""
    CONFIG_FILE.write_text(json.dumps(CONFIG, indent=2))

# ---------------- Config ----------------
CONFIG_DIR = Path(os.path.expanduser("~/.pwa_manager"))
CONFIG_FILE = CONFIG_DIR / "config.json"
ICON_DIR = Path(os.path.expanduser("~/.local/share/icons/hicolor/512x512/apps/"))
DESKTOP_DIR = Path(os.path.expanduser("~/.local/share/applications/"))
LOG_FILE = CONFIG_DIR / "launch.log"

PRESET_DOMAIN_MAP = {
    # Cloud Gaming
    "xbox.com": "Xbox Cloud Gaming",
    "geforcenow.com": "GeForce NOW",
    "luna.amazon.com": "Amazon Luna",
    "boosteroid.com": "Boosteroid",

    # =================== AI & Search ===================
    "chatgpt.com": "ChatGPT",
    "claude.ai": "Claude",
    "x.ai": "Grok",
    "gemini.google.com": "Gemini",
    "perplexity.ai": "Perplexity",

    # =================== Productivity & Daily Work ===================
    "mail.google.com": "Gmail",
    "calendar.google.com": "Google Calendar",
    "keep.google.com": "Google Keep",
    "drive.google.com": "Google Drive",
    "docs.google.com": "Google Docs",
    "spreadsheets": "Google Sheets",
    "presentation": "Google Slides",
    "office.com": "Microsoft 365",
    "outlook.live.com": "Outlook Web",
    "onedrive.live.com": "OneDrive",
    "notion.so": "Notion",
    "clickup.com": "ClickUp",
    "trello.com": "Trello",
    "todoist.com": "Todoist",
    "ticktick.com": "TickTick",
    "miro.com": "Miro",
    "canva.com": "Canva",
    "lucid.app": "Lucidchart",
    "excalidraw.com": "Excalidraw",
    "diagrams.net": "diagrams.net",

    # =================== Communication ===================
    "discord.com": "Discord",
    "slack.com": "Slack",
    "microsoft.com": "Microsoft Teams",   # covers teams.microsoft.com
    "zoom.us": "Zoom Web",
    "meet.google.com": "Google Meet",

    # =================== Social ===================
    "x.com": "X / Twitter",
    "reddit.com": "Reddit",
    "instagram.com": "Instagram",
    "facebook.com": "Facebook",
    "linkedin.com": "LinkedIn",
    "pinterest.com": "Pinterest",
    "bsky.app": "Bluesky",
    "5mind.com": "5MIND",

    # =================== Streaming ===================
    "youtube.com": "youtube",
    "music.youtube.com": "youtube Music",
    "netflix.com": "Netflix",
    "disneyplus.com": "Disney+",
    "primevideo.com": "Prime Video",
    "spotify.com": "Spotify Web",
    "twitch.tv": "Twitch",
    "crunchyroll.com": "Crunchyroll",
    "plex.tv": "Plex Web",
    "stremio.com": "Stremio Web",
    "hulu.com": "Hulu",
    "aniwatchtv.to": "AniWatch",
    "max.com": "Max (HBO)",
    "peacocktv.com": "Peacock",
    "paramountplus.com": "Paramount+",
    "tv.apple.com": "Apple TV+",
    "kick.com": "Kick",
    "rumble.com": "Rumble",
    "hianime.to": "Hianime",
    "capcut.com": "Capcut",

    # =================== Cloud Gaming ===================
    "airgpu.com": "AirGPU",

    # =================== Art & Creation ===================
    "photopea.com": "Photopea (Photoshop)",
    "figma.com": "Figma",
    "clipstudio.net": "Clip Studio Paint Web",
    "sketchfab.com": "Sketchfab",
    "pixlr.com": "Pixlr Editor",
    "remove.bg": "Remove.bg",

    # =================== VTuber & Streaming Tools ===================
    "streamlabs.com": "Streamlabs OBS Web",
    "ko-fi.com": "Ko-fi",
    "patreon.com": "Patreon",
    "throne.com": "Throne (Wishlist)",
    "streamelements.com": "Streamelements",
    "studio.youtube.com": "youtube Studio",

    # =================== Utilities ===================
    "translate.google.com": "Google Translate",
    "deepl.com": "DeepL Translate",
    "speedtest.net": "Speedtest.net",
    "fast.com": "Fast.com",
    "pomofocus.io": "Pomofocus Timer",
    "mynoise.net": "myNoise.net",
    "rainymood.com": "Rainy Mood",
    "radio.garden": "Radio Garden",
    "ilovepdf.com": "ILovePDF",
    "tinypng.com": "TinyPNG",
    "khanacademy.org": "Khan Academy",
    "duolingo.com": "Duolingo",
    "yummly.com": "Yummly",
    "starbucks.com": "Starbucks Order",

    # =================== Shopping ===================
    "amazon.com": "Amazon",
    "ebay.com": "eBay",
    "aliexpress.com": "AliExpress",
    "walmart.com": "Walmart",
    "target.com": "Target",
    "bestbuy.com": "Best Buy",
    "etsy.com": "Etsy",
    "trivago.com": "Trivago",
    "uber.com": "Uber Web",

    # =================== News & Knowledge ===================
    "wikipedia.org": "Wikipedia",
    "bbc.com": "BBC News",
    "reuters.com": "Reuters",
    "theverge.com": "The Verge",
    "techcrunch.com": "TechCrunch",
    "ycombinator.com": "Hacker News",
    "wolframalpha.com": "Wolfram Alpha",
    "cnn.com": "CNN",
    "nytimes.com": "The New York Times",
    "washingtonpost.com": "The Washington Post",
    "forbes.com": "Forbes",
}



DEFAULT_EXT_PRESETS = {
    "twitch": [
        {"name": "BetterTTV", "web_url": "https://chromewebstore.google.com/detail/betterttv/ajopnjidmegmdimjlfnijceegpefgped"},
        {"name": "FrankerFaceZ", "web_url": "https://chromewebstore.google.com/detail/frankerfacez/fadndhdgpmmaapbmfcknlfgcflmmmieb"},
        {"name": "7TV", "web_url": "https://chromewebstore.google.com/detail/7tv/ammjkodgmmoknidbanneddgankgfejfh"},
    ],
    "kick": [
        {"name": "NipahTV (Emotes + Chat Enhancements)", "web_url": "https://chromewebstore.google.com/detail/nipahtv/bjggmgekoncaaalaalhchepgkjoahjln"},
        {"name": "7TV", "web_url": "https://chromewebstore.google.com/detail/7tv/ammjkodgmmoknidbanneddgankgfejfh"},
    ],
    "youtube": [
        {"name": "SponsorBlock", "web_url": "https://chromewebstore.google.com/detail/sponsorblock-for-youtube/mnjggcdmjocbbbhaepdhchncahnbgone"},
        {"name": "uBlock Origin", "web_url": "https://chromewebstore.google.com/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm"},
        {"name": "Return YouTube Dislike", "web_url": "https://chromewebstore.google.com/detail/return-youtube-dislike/gebbhagfogifgggkldgodflihgfeippi"},
        {"name": "Unhook for YouTube", "web_url": "https://chromewebstore.google.com/detail/unhook-remove-youtube-rec/agbjjhcakilocfjoidcmclcoidipnnhl"},
        {"name": "Enhancer for YouTube", "web_url": "https://chromewebstore.google.com/detail/enhancer-for-youtube/ponfelnnbfdgchaoffdenecfgkfklngg"},
        {"name": "DeArrow", "web_url": "https://chromewebstore.google.com/detail/dearrow-title-thumbnail-f/ibgpcpbhkbhjcmfnhiepghebomnipido"},
        {"name": "YouTube NonStop", "web_url": "https://chromewebstore.google.com/detail/youtube-nonstop/ajioplkfknbldfggjllgmojioedcjhkf"},
    ],
    "Google Docs": [
        {"name": "super styles for google docs", "web_url": "https://workspace.google.com/u/0/marketplace/app/super_styles_for_google_docs/749048387655"},
        {"name": "code blocks for  google docs", "web_url": "https://workspace.google.com/u/0/marketplace/app/code_blocks/100740430168"},
        {"name": "Grammare and spell check for google docs", "web_url":  "https://workspace.google.com/u/0/marketplace/app/grammar_and_spell_checker_languagetool/805250893316"},
        {"name": "DocSecrets", "web_url": "https://workspace.google.com/marketplace/app/docsecrets/106495793380"},
        {"name": "DocTools", "web_url": "https://workspace.google.com/marketplace/app/doctools/812550428155"},
        {"name": "Text Cleaner", "web_url": "https://workspace.google.com/marketplace/app/text_cleaner/590957751694"},
        {"name": "Table of Contents Add-On", "web_url": "https://workspace.google.com/marketplace/app/table_of_contents/673827206993"},
    ],
    "Google Sheets": [
        {"name": "Power Tools", "web_url": "https://workspace.google.com/marketplace/app/power_tools/1058867473888"},
        {"name": "Advanced Find & Replace", "web_url": "https://workspace.google.com/marketplace/app/advanced_find_replace/1042060810936"},
    ],
    "Google Slides": [
        {"name": "Slides Toolbox", "web_url": "https://workspace.google.com/marketplace/app/slides_toolbox/303181111203"},
    ],
    "Google Drive": [
        {"name": "Save to Google Drive Button", "web_url": "https://chromewebstore.google.com/detail/save-to-google-drive/gmbmikajjgmnabiglmofipeabaddhgne"},
    ],
    "Reddit": [
        {"name": "Reddit Enhancement Suite (RES)", "web_url": "https://chromewebstore.google.com/detail/reddit-enhancement-suite/kbpojkailcjolinmakdefkkcjkcimeoa"},
        {"name": "Old Reddit Redirect", "web_url": "https://chromewebstore.google.com/detail/old-reddit-redirect/pinhfnpggfpgpbkllgidmclklgljlijl"},
    ],
    "X / Twitter": [
        {"name": "Control Panel for Twitter", "web_url": "https://chromewebstore.google.com/detail/control-panel-for-twitter/dkboeeeenhalhjemdfeehiakblbkocbm"},
        {"name": "GoodTwitter 2", "web_url": "https://chromewebstore.google.com/detail/goodtwitter2/ojhmphdkpgbibohbihfgmfgphojmpidd"},
        {"name": "Hide Promoted Posts for Twitter", "web_url": "https://chromewebstore.google.com/detail/hide-promoted-tweets/bkhbpbbbjbpjpmcjoemilnbibhhfcpfo"},
    ],
    "Instagram": [
        {"name": "Web for Instagram Plus DM Tools", "web_url": "https://chromewebstore.google.com/detail/web-for-instagram-with-dm/ifcmnnhkkddkggmbggojfajbgbhjfgcj"},
        {"name": "Inssist Web Enhancer", "web_url": "https://chromewebstore.google.com/detail/inssist-lite/bodncoafpljjafcfdajpheodjbjfljkk"},
    ],
    "Facebook": [
        {"name": "FB Purity", "web_url": "https://chromewebstore.google.com/detail/fb-purity-clean-up-facebook/lhfdgjlabncfcbnolpjnpeepffkfoich"},
        {"name": "Social Fixer", "web_url": "https://chromewebstore.google.com/detail/social-fixer-for-facebook/lbdkchheehjoocbbpnkgmnmkgcodionf"},
    ],
    "Discord": [
        {"name": "Discord Theme Injector", "web_url": "https://chromewebstore.google.com/detail/theme-injector-for-discord/oodljbhpfjglgfkddbjdchbllkaeeboc"},
        {"name": "BetterDiscord Web Tweaks", "web_url": "https://chromewebstore.google.com/detail/betterdiscord-web/hcbpjfjmhadnlekookpimnhiohjhjhna"},
    ],
    "Netflix": [
        {"name": "Netflix Extended", "web_url": "https://chromewebstore.google.com/detail/netflix-extended/bhplkbgoehhhddaecmdaohpebcglgbaa"},
        {"name": "Super Netflix", "web_url": "https://chromewebstore.google.com/detail/super-netflix/nlcbkpgbhjjnclnndmlbkjnhcphljfff"},
    ],
    "Disney+": [
        {"name": "Disney+ Hotkeys", "web_url": "https://chromewebstore.google.com/detail/disney-hotkeys/omimjmlmcpiimjdpvjhjyayekhqppcbb"},
    ],
    "Prime Video": [
        {"name": "Prime Video Enhancer", "web_url": "https://chromewebstore.google.com/detail/prime-video-extended/keigkbhgjjdjnpgehpenfpkpkppojlcn"},
    ],
    "Hulu": [
        {"name": "Hulu Hotkeys", "web_url": "https://chromewebstore.google.com/detail/hulu-keyboard-controls/ehfnocfijmmlhmhfhfkbawo1stmjhqrs"},
    ],
    "Spotify Web": [
        {"name": "Spotify Tree Navigation", "web_url": "https://chromewebstore.google.com/detail/tree-style-tab-for-spotif/mkcjquizjjhfkfbysptwp891z4p04zlf"},
        {"name": "Spotify Visualizer", "web_url": "https://chromewebstore.google.com/detail/spotify-visualizer/ojllcjggccimihgojokahbahkofhabbo"},
    ],
    "Amazon": [
        {"name": "Honey", "web_url": "https://chromewebstore.google.com/detail/paypal-honey-automatic-cou/mbckjcfnjmoiagmdehgmjhmehgdafkog"},
        {"name": "Rakuten Cash Back", "web_url": "https://chromewebstore.google.com/detail/rakuten-cash-back-button/kfbdmcokinfnbgkafhbbebgaolhldljl"},
        {"name": "Keepa Price Tracker", "web_url": "https://chromewebstore.google.com/detail/keepa-amazon-price-tracker/neebplgakaahbhdphmkckjjcegoiijjo"},
        {"name": "Fakespot Review Analyzer", "web_url": "https://chromewebstore.google.com/detail/fakespot-analyzer/mhkfjnjlajhemjjmlgcboghkbikkcjif"},
    ],
    "Notion": [
        {"name": "Notion Boost", "web_url": "https://chromewebstore.google.com/detail/notion-boost/fpjpmgnjinhkjcjbhcballlkpcefnplh"},
    ],
    "Trello": [
        {"name": "Card Aging Assistant", "web_url": "https://chromewebstore.google.com/detail/trello-card-ageing/iplpocngbmgkofkfecadangmlpdhkoem"},
    ],
    "ClickUp": [
        {"name": "ClickUp Hotkeys Enhancer", "web_url": "https://chromewebstore.google.com/detail/clickup-enhancer/bmkfpiidgmobgomieofhpaohgjcamkmm"},
    ],
    "Gmail": [
        {"name": "Simplify Gmail", "web_url": "https://chromewebstore.google.com/detail/simplify-gmail/pnhplgjpclknigjpcckkpaeoemljnchg"},
        {"name": "Gmail Sender Icons", "web_url": "https://chromewebstore.google.com/detail/sender-icons-for-gmail/nkfabcolfplmlijojjgcfdffoehibbfg"},
    ],
    "Google Calendar": [
        {"name": "Event Merge", "web_url": "https://chromewebstore.google.com/detail/event-merge-for-google-cal/dlifekfklhbcbgponifgpdbcopbekmna"},
    ],
}


DEFAULT_APPS = [
     # =================== AI & Search (2025 Essentials) ===================
    {"name": "ChatGPT", "url": "https://chatgpt.com", "kiosk": False},
    {"name": "Claude", "url": "https://claude.ai", "kiosk": False},
    {"name": "Grok", "url": "https://grok.x.ai", "kiosk": False},
    {"name": "Gemini", "url": "https://gemini.google.com", "kiosk": False},
    {"name": "Perplexity", "url": "https://perplexity.ai", "kiosk": False},

    # =================== Productivity & Daily Work ===================
    {"name": "Gmail", "url": "https://mail.google.com", "kiosk": False},
    {"name": "Google Calendar", "url": "https://calendar.google.com", "kiosk": False},
    {"name": "Google Keep", "url": "https://keep.google.com", "kiosk": False},
    {"name": "Google Drive", "url": "https://drive.google.com", "kiosk": False},
    {"name": "Google Docs", "url": "https://docs.google.com/document/", "kiosk": False},
    {"name": "Google Sheets", "url": "https://docs.google.com/spreadsheets/", "kiosk": False},
    {"name": "Google Slides", "url": "https://docs.google.com/presentation/", "kiosk": False},
    {"name": "Microsoft 365", "url": "https://www.office.com", "kiosk": False},
    {"name": "Outlook Web", "url": "https://outlook.live.com", "kiosk": False},
    {"name": "OneDrive", "url": "https://onedrive.live.com", "kiosk": False},
    {"name": "Notion", "url": "https://www.notion.so", "kiosk": False},
    {"name": "ClickUp", "url": "https://app.clickup.com", "kiosk": False},
    {"name": "Trello", "url": "https://trello.com", "kiosk": False},
    {"name": "Todoist", "url": "https://todoist.com", "kiosk": False},
    {"name": "TickTick", "url": "https://ticktick.com", "kiosk": False},
    {"name": "Miro", "url": "https://miro.com", "kiosk": False},
    {"name": "Canva", "url": "https://www.canva.com", "kiosk": False},
    {"name": "Lucidchart", "url": "https://lucid.app", "kiosk": False},
    {"name": "Excalidraw", "url": "https://excalidraw.com", "kiosk": False},
    {"name": "diagrams.net", "url": "https://app.diagrams.net", "kiosk": False},

    # =================== Communication (Everyone Uses) ===================
    {"name": "Discord", "url": "https://discord.com/app", "kiosk": False},
    {"name": "Slack", "url": "https://app.slack.com", "kiosk": False},
    {"name": "Microsoft Teams", "url": "https://teams.microsoft.com", "kiosk": False},
    {"name": "Zoom Web", "url": "https://zoom.us/join", "kiosk": False},
    {"name": "Google Meet", "url": "https://meet.google.com", "kiosk": False},

    # =================== Social (Mainstream) ===================
    {"name": "X / Twitter", "url": "https://x.com", "kiosk": False},
    {"name": "Reddit", "url": "https://www.reddit.com", "kiosk": False},
    {"name": "Instagram", "url": "https://www.instagram.com", "kiosk": False},
    {"name": "Facebook", "url": "https://www.facebook.com", "kiosk": False},
    {"name": "LinkedIn", "url": "https://www.linkedin.com", "kiosk": False},
    {"name": "Pinterest", "url": "https://www.pinterest.com", "kiosk": False},
    {"name": "Bluesky", "url": "https://bsky.app", "kiosk": False},
    {"name": "5MIND", "url": "https://5mind.com/", "kiosk": False},

    # =================== Streaming & Entertainment (Big Ones) ===================
    {"name": "youtube", "url": "https://www.youtube.com", "kiosk": False},
    {"name": "youtube Music", "url": "https://music.youtube.com", "kiosk": False},
    {"name": "Netflix", "url": "https://www.netflix.com", "kiosk": False},
    {"name": "Disney+", "url": "https://www.disneyplus.com", "kiosk": False},
    {"name": "Prime Video", "url": "https://www.primevideo.com", "kiosk": False},
    {"name": "Spotify Web", "url": "https://open.spotify.com", "kiosk": False},
    {"name": "Twitch", "url": "https://www.twitch.tv", "kiosk": False},
    {"name": "Crunchyroll", "url": "https://www.crunchyroll.com", "kiosk": False},
    {"name": "Plex Web", "url": "https://app.plex.tv", "kiosk": False},
    {"name": "Stremio Web", "url": "https://web.stremio.com", "kiosk": False},
    {"name": "Hulu", "url": "https://www.hulu.com", "kiosk": False},
    {"name": "AniWatch", "url": "https://aniwatchtv.to/", "kiosk": False},
    {"name": "Max (HBO)", "url": "https://max.com", "kiosk": False},
    {"name": "Peacock", "url": "https://www.peacocktv.com", "kiosk": False},
    {"name": "Paramount+", "url": "https://www.paramountplus.com", "kiosk": False},
    {"name": "Apple TV+", "url": "https://tv.apple.com", "kiosk": False},
    {"name": "Kick", "url": "https://kick.com", "kiosk": False},
    {"name": "Rumble", "url": "https://rumble.com", "kiosk": False},
    {"name": "Hianime", "url": "https://hianime.to/", "kiosk": False},
    {"name": "Capcut", "url": "https://www.capcut.com/", "kiosk": False},

    # =================== Gaming & Cloud Gaming (Actively Working 2025) ===================
    {"name": "Xbox Cloud Gaming", "url": "https://www.xbox.com/play", "kiosk": True},
    {"name": "GeForce NOW", "url": "https://play.geforcenow.com", "kiosk": True, "browser": "firefox"},
    {"name": "Amazon Luna", "url": "https://luna.amazon.com", "kiosk": True, "browser": "firefox"},
    {"name": "Boosteroid", "url": "https://boosteroid.com/go", "kiosk": True, "browser": "firefox"},
    {"name": "AirGPU", "url": "https://airgpu.com", "kiosk": True, "browser": "firefox"},

    # =================== Art, Design & Creation ===================
    {"name": "Photopea (Photoshop)", "url": "https://www.photopea.com", "kiosk": False},
    {"name": "Figma", "url": "https://www.figma.com", "kiosk": False},
    {"name": "Clip Studio Paint Web", "url": "https://www.clipstudio.net", "kiosk": False},
    {"name": "Sketchfab", "url": "https://sketchfab.com", "kiosk": False},
    {"name": "Pixlr Editor", "url": "https://pixlr.com", "kiosk": False},
    {"name": "Remove.bg", "url": "https://www.remove.bg", "kiosk": False},

    # =================== VTuber & Streaming Tools ===================
    {"name": "Streamlabs OBS Web", "url": "https://streamlabs.com", "kiosk": False},
    {"name": "Ko-fi", "url": "https://ko-fi.com", "kiosk": False},
    {"name": "Patreon", "url": "https://www.patreon.com", "kiosk": False},
    {"name": "Throne (Wishlist)", "url": "https://throne.com", "kiosk": False},
    {"name": "Streamelements", "url": "https://streamelements.com", "kiosk": False},
    {"name": "Streamlabs Dashboard", "url": "https://streamlabs.com/dashboard", "kiosk": False},
    {"name": "youtube Studio", "url": "https://studio.youtube.com", "kiosk": False},

    # =================== Utilities Everyone Needs ===================
    {"name": "Google Translate", "url": "https://translate.google.com", "kiosk": False},
    {"name": "DeepL Translate", "url": "https://www.deepl.com/translator", "kiosk": False},
    {"name": "Speedtest.net", "url": "https://www.speedtest.net", "kiosk": False},
    {"name": "Fast.com", "url": "https://fast.com", "kiosk": False},
    {"name": "Pomofocus Timer", "url": "https://pomofocus.io", "kiosk": False},
    {"name": "myNoise.net", "url": "https://mynoise.net", "kiosk": False},
    {"name": "Rainy Mood", "url": "https://www.rainymood.com", "kiosk": False},
    {"name": "Radio Garden", "url": "https://radio.garden", "kiosk": False},
    {"name": "ILovePDF", "url": "https://www.ilovepdf.com", "kiosk": False},
    {"name": "TinyPNG", "url": "https://tinypng.com", "kiosk": False},
    {"name": "Khan Academy", "url": "https://www.khanacademy.org", "kiosk": False},
    {"name": "Duolingo", "url": "https://www.duolingo.com", "kiosk": False},
    {"name": "Yummly (Recipes)", "url": "https://www.yummly.com", "kiosk": False},
    {"name": "Starbucks Order", "url": "https://app.starbucks.com", "kiosk": False},

    # =================== Shopping (Big Global Players) ===================
    {"name": "Amazon", "url": "https://www.amazon.com", "kiosk": False},
    {"name": "eBay", "url": "https://www.ebay.com", "kiosk": False},
    {"name": "AliExpress", "url": "https://www.aliexpress.com", "kiosk": False},
    {"name": "Walmart", "url": "https://www.walmart.com", "kiosk": False},
    {"name": "Target", "url": "https://www.target.com", "kiosk": False},
    {"name": "Best Buy", "url": "https://www.bestbuy.com", "kiosk": False},
    {"name": "Etsy", "url": "https://www.etsy.com", "kiosk": False},
    {"name": "Trivago", "url": "https://www.trivago.com", "kiosk": False},
    {"name": "Uber Web", "url": "https://m.uber.com", "kiosk": False},

    # =================== News & Knowledge ===================
    {"name": "Wikipedia", "url": "https://www.wikipedia.org", "kiosk": False},
    {"name": "BBC News", "url": "https://www.bbc.com/news", "kiosk": False},
    {"name": "Reuters", "url": "https://www.reuters.com", "kiosk": False},
    {"name": "The Verge", "url": "https://www.theverge.com", "kiosk": False},
    {"name": "TechCrunch", "url": "https://techcrunch.com", "kiosk": False},
    {"name": "Hacker News", "url": "https://news.ycombinator.com", "kiosk": False},
    {"name": "Wolfram Alpha", "url": "https://www.wolframalpha.com", "kiosk": False},
    {"name": "CNN", "url": "https://edition.cnn.com", "kiosk": False},
    {"name": "The New York Times", "url": "https://www.nytimes.com", "kiosk": False},
    {"name": "The Washington Post", "url": "https://www.washingtonpost.com", "kiosk": False},
    {"name": "Forbes", "url": "https://www.forbes.com", "kiosk": False},
]

DEFAULT_CONFIG = {
    "apps": DEFAULT_APPS,
    "browser": None,  # Will be auto-detected
    "gpu": True,
    "kiosk": False,
    "nice": 0,
    "ionice": 2,
    "dark_mode": True,
    "session_type": None,  # Will be detected
    "available_browsers": {},  # Will be populated
    "browsers": {
        "firefox": {
            "args": "--profile={profile_dir} --no-remote {kiosk_flag}{url}",
            "kiosk_flag": "--kiosk ",
            "app_mode": False,
            "ext_base": "https://addons.mozilla.org/en-US/firefox/addon/",
            "store_url": "https://addons.mozilla.org/en-US/firefox/", 
            "ext_dir": "extensions",
            "ext_suffix": ".xpi"
        },
        "edge": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://microsoftedge.microsoft.com/addons/detail/",
            "store_url": "https://microsoftedge.microsoft.com/addons/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
        "brave": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://chromewebstore.google.com/detail/",
            "store_url": "https://chromewebstore.google.com/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
        "vivaldi": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://chromewebstore.google.com/detail/",
            "store_url": "https://chromewebstore.google.com/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
        "chrome": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://chromewebstore.google.com/detail/",
            "store_url": "https://chromewebstore.google.com/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
        "chromium": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://chromewebstore.google.com/detail/",
            "store_url": "https://chromewebstore.google.com/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
        "opera": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://addons.opera.com/en/extensions/details/",
            "store_url": "https://addons.opera.com/en/",
            "ext_dir": "Extensions",
            "ext_suffix": ".nex",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events"
        },
        "ungoogled-chromium": {
            "args": "--user-data-dir={profile_dir} --app={url} {kiosk_flag}",
            "kiosk_flag": "--start-fullscreen",
            "app_mode": True,
            "ext_base": "https://chromewebstore.google.com/detail/",
            "store_url": "https://chromewebstore.google.com/", 
            "ext_dir": "Extensions",
            "ext_suffix": ".crx",
            "extra_flags": "--enable-features=WebHID --enable-gamepad-button-axis-events --disable-features=WebHidBlocklist"
        },
    },
}

# Load config
CONFIG_DIR.mkdir(parents=True, exist_ok=True)
if CONFIG_FILE.exists():
    try:
        CONFIG = json.loads(CONFIG_FILE.read_text())
    except Exception:
        CONFIG = DEFAULT_CONFIG.copy()
else:
    CONFIG = DEFAULT_CONFIG.copy()

# Detect system configuration
CONFIG["session_type"] = get_session_type()
CONFIG["available_browsers"] = scan_available_browsers()

# Always refresh default browser detection on startup
# This ensures we use the current system default, not a stale saved value
detected_default = get_default_browser()
CONFIG["browser"] = detected_default

# Config migration
apps_collection = CONFIG.get("apps", [])
if not isinstance(apps_collection, dict):
    CONFIG["apps"] = {slugify(app["name"]): app for app in apps_collection if isinstance(app, dict) and "name" in app}

existing_names = {app["name"] for app in CONFIG["apps"].values()}
for app in DEFAULT_APPS:
    app_slug = slugify(app["name"])
    if app["name"] not in existing_names and app_slug not in CONFIG["apps"]:
        # Set browser to default if not specified
        if "browser" not in app:
            app["browser"] = CONFIG["browser"]
        CONFIG["apps"][app_slug] = app

CONFIG.setdefault("browsers", {})
for browser_key, default_data in DEFAULT_CONFIG["browsers"].items():
    if browser_key not in CONFIG["browsers"]:
        CONFIG["browsers"][browser_key] = default_data
    else:
        for key, value in default_data.items():
            CONFIG["browsers"][browser_key].setdefault(key, value)

CONFIG.setdefault("dark_mode", True)
save_config()

# Log detected configuration
print(f"[Appify] Session: {CONFIG['session_type']}")
print(f"[Appify] Default browser: {CONFIG['browser']}")
print(f"[Appify] Available browsers: {', '.join(CONFIG['available_browsers'].keys())}")

# ---------------- Install/Uninstall ----------------

def init_firefox_profile(profile_dir: Path, app: dict):
    """
    Pre-initialises a Firefox profile directory so it behaves as an isolated PWA.

    Firefox only populates its profile with .db files and other data the first
    time the binary actually runs against that directory.  Without this seed
    file the profile folder is empty, the --no-remote guard fails to isolate
    it properly, and the PWA opens inside whatever Firefox window is already
    on screen instead of in its own dedicated instance.

    Writing user.js is the standard, documented way to pre-configure a Firefox
    profile.  Firefox reads it on every startup and copies every preference
    listed there into prefs.js, which is the live preferences file.  We set:

      • A unique profile name so the OS window list shows the app name.
      • browser.startup.homepage set to the PWA URL so it opens on first launch.
      • All first-run / welcome / telemetry / sync UI disabled — these would
        hijack the first window and break the PWA experience.
      • toolkit.singletonWindowType cleared so multiple isolated profiles can
        each open their own top-level window at the same time.
      • browser.tabs.warnOnClose / warnOnQuit disabled for clean exit.
    """
    profile_dir.mkdir(parents=True, exist_ok=True)

    app_name = app.get("name", "PWA")
    app_url  = app.get("url", "about:blank")

    user_js_content = f"""\
// Generated by Appify – do not edit by hand.
// This file is re-read by Firefox on every startup and merged into prefs.js.

// ── Identity ──────────────────────────────────────────────────────────────
user_pref("profile.name", "{app_name}");

// ── Startup ───────────────────────────────────────────────────────────────
// 0 = blank, 1 = home page, 2 = last session, 3 = resume previous session
user_pref("browser.startup.page", 1);
user_pref("browser.startup.homepage", "{app_url}");

// ── First-run / welcome UI (suppress completely) ───────────────────────
user_pref("browser.startup.firstrunSkipsHomepage", true);
user_pref("browser.startup.homepage_override.mstone", "ignore");
user_pref("startup.homepage_welcome_url", "");
user_pref("startup.homepage_welcome_url.additional", "");
user_pref("startup.homepage_override_url", "");
user_pref("browser.laterrun.enabled", false);
user_pref("browser.uitour.enabled", false);
user_pref("trailhead.firstrun.didSeeAboutWelcome", true);
user_pref("browser.aboutwelcome.enabled", false);

// ── New-tab page (keep it minimal, not a distraction) ─────────────────
user_pref("browser.newtabpage.enabled", false);
user_pref("browser.newtab.preload", false);
user_pref("browser.newtabpage.activity-stream.feeds.telemetry", false);
user_pref("browser.newtabpage.activity-stream.telemetry", false);
user_pref("browser.newtabpage.activity-stream.feeds.snippets", false);
user_pref("browser.newtabpage.activity-stream.feeds.section.topstories", false);
user_pref("browser.newtabpage.activity-stream.feeds.discoverystreamfeed", false);
user_pref("browser.newtabpage.activity-stream.showSponsored", false);
user_pref("browser.newtabpage.activity-stream.showSponsoredTopSites", false);

// ── Telemetry / data collection ────────────────────────────────────────
user_pref("toolkit.telemetry.reportingpolicy.firstRun", false);
user_pref("toolkit.telemetry.unified", false);
user_pref("toolkit.telemetry.enabled", false);
user_pref("toolkit.telemetry.server", "");
user_pref("toolkit.telemetry.archive.enabled", false);
user_pref("toolkit.telemetry.newProfilePing.enabled", false);
user_pref("toolkit.telemetry.shutdownPingSender.enabled", false);
user_pref("toolkit.telemetry.updatePing.enabled", false);
user_pref("toolkit.telemetry.bhrPing.enabled", false);
user_pref("toolkit.telemetry.firstShutdownPing.enabled", false);
user_pref("datareporting.healthreport.uploadEnabled", false);
user_pref("datareporting.policy.dataSubmissionEnabled", false);
user_pref("datareporting.policy.firstRunURL", "");

// ── Sync / accounts (not needed for a PWA profile) ────────────────────
user_pref("identity.fxaccounts.enabled", false);

// ── Extension recommendations (noisy, irrelevant for PWA) ─────────────
user_pref("extensions.getAddons.showPane", false);
user_pref("extensions.htmlaboutaddons.recommendations.enabled", false);
user_pref("browser.discovery.enabled", false);

// ── Window behaviour ──────────────────────────────────────────────────
// Allows multiple independent Firefox profiles to each have their own
// top-level window open simultaneously (required for --no-remote).
user_pref("toolkit.singletonWindowType", "");
user_pref("browser.tabs.warnOnClose", false);
user_pref("browser.tabs.warnOnCloseOtherTabs", false);
user_pref("browser.warnOnQuit", false);
user_pref("browser.sessionstore.resume_from_crash", false);

// ── Security defaults (keep sensible values) ─────────────────────────
user_pref("security.sandbox.content.level", 2);
"""

    user_js_path = profile_dir / "user.js"
    # Only write if the file doesn't already exist, so manual edits are preserved.
    if not user_js_path.exists():
        try:
            user_js_path.write_text(user_js_content, encoding="utf-8")
        except Exception as e:
            print(f"[Appify] Warning: could not write user.js for Firefox profile: {e}")


def install_app(app, browser_key, kiosk, nice, ionice, gpu, status_callback=None):
    if 'url' in app and ('name' not in app or not app['name']):
        parsed_url = urlparse(app['url'])
        app['name'] = parsed_url.netloc or 'Custom PWA'
        
    app_slug = slugify(app["name"])
    
    # Verify browser is available
    detection = detect_browser_installation(browser_key)
    if detection['type'] == 'not_found':
        if status_callback:
            status_callback(f"Error: {browser_key} is not installed")
        return
    
    profile_dir = get_profile_dir(app)
    profile_dir.mkdir(parents=True, exist_ok=True)

    # Firefox needs its profile directory pre-seeded with a user.js so that
    # it launches as a proper isolated PWA instance.  Chromium-based browsers
    # build their full profile structure automatically on first launch via
    # --user-data-dir; Firefox does not do this until the binary actually runs,
    # which means without this step the profile folder stays empty and Firefox
    # ignores --no-remote, opening URLs inside an existing window instead.
    if browser_key.lower() == "firefox":
        init_firefox_profile(profile_dir, app)
        if status_callback:
            status_callback(f"Firefox profile initialised for {app['name']}")

    profile_cfg = load_profile_config(app)
    profile_cfg["browser"] = browser_key.lower()
    profile_cfg["gamepad"] = app.get("gamepad", False)
    profile_cfg["browser_type"] = detection['type']
    save_profile_config(app, profile_cfg)
    marker = profile_dir / "installed.marker"
    marker.write_text("installed\n")
    download_icon(app, status_callback)
    create_desktop_file(app, os.path.abspath(sys.argv[0]), status_callback)
    
    if app_slug not in CONFIG["apps"]:
        CONFIG["apps"][app_slug] = app

    save_config()
    
    if status_callback: 
        status_callback(f"Installed: {app['name']} ({detection['display_name']})")

def remove_app_files(app_to_remove):
    app_slug = slugify(app_to_remove['name'])
    
    scripts_dir = CONFIG_DIR / "scripts"
    wrapper = scripts_dir / f"pwa-launch-{app_slug}.sh"
    wrapper.unlink(missing_ok=True)
    
    profile_dir = get_profile_dir(app_to_remove)
    marker = profile_dir / "installed.marker"
    desktop_path = get_desktop_file_path(app_to_remove)
    icon_path = get_icon_path(app_to_remove)
    
    marker.unlink(missing_ok=True)
    desktop_path.unlink(missing_ok=True)
    icon_path.unlink(missing_ok=True)
    
    subprocess.run(["update-desktop-database", "-q", str(DESKTOP_DIR)], check=False)

def uninstall_app(name):
    app_slug = slugify(name)
    app_to_remove = CONFIG["apps"].pop(app_slug, None)
        
    if app_to_remove:
        remove_app_files(app_to_remove)
        save_config() 

def list_installed_apps():
    profiles_root = CONFIG_DIR / "profiles"
    installed = []
    if profiles_root.is_dir():
        for p in profiles_root.iterdir():
            if p.is_dir() and (p / "installed.marker").exists():
                installed.append(p.name)
    return installed

def find_app_by_name(name):
    for app in CONFIG["apps"].values():
        if app.get("name") == name:
            return app
    return None

def log_debug(msg):
    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(LOG_FILE, "a") as f:
        f.write(f"[DEBUG] {msg}\n")
    print(msg, file=sys.stderr)

def launch_app_from_cli(app_name: str):
    app = find_app_by_name(app_name)
    if not app:
        print(f"ERROR: App '{app_name}' not found.", file=sys.stderr)
        sys.exit(1)

    profile_dir = get_profile_dir(app)
    profile_cfg = load_profile_config(app)
    browser_key = (profile_cfg.get("browser") or app.get("browser") or CONFIG.get("browser", "firefox")).lower()
    
    detection = detect_browser_installation(browser_key)
    if detection['type'] == 'not_found':
        print(f"ERROR: Browser '{browser_key}' not found.", file=sys.stderr)
        sys.exit(1)

    kiosk_flag = CONFIG["browsers"][browser_key].get("kiosk_flag", "") if app.get("kiosk", False) else ""
    gpu = CONFIG.get("gpu", True)
    nice_val = CONFIG.get("nice", 0)
    ionice_val = CONFIG.get("ionice", 2)

    try:
        wrapper = make_launcher_wrapper(app, browser_key, nice_val, ionice_val, gpu)
        
        log_debug(f"LAUNCH: {app_name} via {detection['display_name']}")
        log_debug(f"WRAPPER: {wrapper}")

        subprocess.Popen(
            [str(wrapper)],
            start_new_session=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        sys.exit(0)

    except Exception as e:
        log_debug(f"LAUNCH ERROR: {e}")
        print(f"Launch failed: {e}", file=sys.stderr)
        sys.exit(1)

def launch_extension_manager(browser_key: str, preset_key: str, profile_dir: Path):
    try:
        browser_config = get_browsers().get(browser_key)
        if not browser_config:
            print(f"ERROR: Browser config not found for {browser_key}")
            return

        detection = detect_browser_installation(browser_key)
        if detection['type'] == 'not_found':
            print(f"ERROR: {browser_key} not installed")
            return

        normalized_key = next(
            (k for k in DEFAULT_EXT_PRESETS.keys() if k.lower() == preset_key.lower()),
            preset_key
        )
        extensions = DEFAULT_EXT_PRESETS.get(normalized_key, [])
        
        if not extensions:
            url = browser_config["store_url"]
            print(f"INFO: No extensions found for preset '{preset_key}'. Launching browser to store: {url}")
            
            if detection['type'] == 'flatpak':
                cmd_list = ["flatpak", "run", detection['flatpak_id'], url]
            elif detection['type'] == 'snap':
                cmd_list = ["snap", "run", browser_key, url]
            else:
                if browser_key.lower() == "firefox":
                    cmd_list = [detection['cmd'], "--profile", str(profile_dir), "--no-remote", url]
                else:
                    cmd_list = [detection['cmd'], f"--user-data-dir={str(profile_dir)}", url]
            subprocess.Popen(cmd_list)
            return

        urls = [
            ext["web_url"]
            for ext in extensions
            if isinstance(ext.get("web_url"), str) and ext["web_url"].strip()
        ]
        
        if not urls:
            return

        if detection['type'] == 'flatpak':
            cmd_list = ["flatpak", "run", detection['flatpak_id']] + urls
        elif detection['type'] == 'snap':
            cmd_list = ["snap", "run", browser_key] + urls
        else:
            if browser_key.lower() == "firefox":
                cmd_list = [detection['cmd'], "--profile", str(profile_dir), "--no-remote"] + urls
            else:
                cmd_list = [detection['cmd'], f"--user-data-dir={str(profile_dir)}"] + urls

        subprocess.Popen(cmd_list)
        print(f"INFO: Launched {detection['display_name']} to install extensions for {preset_key}.")

    except Exception as e:
        print(f"An unexpected error occurred: {e}")

# ---------------- GTK4 UI ----------------
Adw.init()

class PWAManagerApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="com.appify", flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.win = None
        self.sorted_apps_list = []

    def do_activate(self):
        if not self.win:
            self.win = PWAManagerWindow(application=self)
        self.win.present()

class PWAManagerWindow(Adw.ApplicationWindow):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        # Display session info in title
        session_info = f" • {CONFIG['session_type'].upper()}" if CONFIG.get('session_type') else ""
        self.set_title(_(f"Appify {CURRENT_VERSION}{session_info}"))
        self.set_default_size(1000, 1050)
        self.sorted_apps_list = []

        self.statusbar = Gtk.Label()
        self.statusbar.set_xalign(0)
        self.statusbar.set_margin_top(10)
        self.statusbar.set_margin_start(10)

        header = Adw.HeaderBar()
        header.set_show_start_title_buttons(True)
        header.set_show_end_title_buttons(True)
        title = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        title.append(Gtk.Label(label=_(f"Appify {CURRENT_VERSION}")))
        subtitle_text = f"Smart Browser Detection • {CONFIG['session_type'].upper() if CONFIG.get('session_type') else 'Unknown'} Session"
        title.append(Gtk.Label(label=subtitle_text))
        header.set_title_widget(title)

        menu_btn = Gtk.MenuButton()
        menu_btn.set_icon_name("open-menu-symbolic")
        menu = Gio.Menu()
        menu.append(_("About"), "win.about")
        menu.append(_("Rescan Browsers"), "win.rescan")
        menu.append(_("Restore Default Apps"), "win.restore_defaults")
        menu_btn.set_menu_model(menu)
        header.pack_end(menu_btn)

        about_action = Gio.SimpleAction.new("about", None)
        about_action.connect("activate", self.show_about_dialog)
        self.add_action(about_action)
        
        rescan_action = Gio.SimpleAction.new("rescan", None)
        rescan_action.connect("activate", self.on_rescan_browsers)
        self.add_action(rescan_action)
        
        restore_action = Gio.SimpleAction.new("restore_defaults", None)
        restore_action.connect("activate", self.on_restore_defaults)
        self.add_action(restore_action)

        mode_box = Gtk.Box(spacing=6)
        mode_box.append(Gtk.Label(label=_("Dark")))
        self.mode_switch = Gtk.Switch()
        self.mode_switch.set_active(CONFIG.get("dark_mode", True))
        self.mode_switch.connect("notify::active", self.on_mode_toggled)
        mode_box.append(self.mode_switch)
        header.pack_start(mode_box)

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        main_box.append(header)

        scroll = Gtk.ScrolledWindow()
        scroll.set_vexpand(True)
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)

        content_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        content_box.set_margin_top(12)
        content_box.set_margin_bottom(12)
        content_box.set_margin_start(12)
        content_box.set_margin_end(12)
        scroll.set_child(content_box)
        main_box.append(scroll)
        self.set_content(main_box)

        # System info banner
        sys_info_frame = Gtk.Frame()
        sys_info_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        sys_info_box.set_margin_top(8)
        sys_info_box.set_margin_bottom(8)
        sys_info_box.set_margin_start(12)
        sys_info_box.set_margin_end(12)
        
        session_label = Gtk.Label()
        session_label.set_markup(f"<b>Display Server:</b> {CONFIG['session_type'].upper()}")
        sys_info_box.append(session_label)
        
        browser_count = len(CONFIG.get('available_browsers', {}))
        browsers_label = Gtk.Label()
        browsers_label.set_markup(f"<b>Browsers Found:</b> {browser_count}")
        sys_info_box.append(browsers_label)
        
        default_browser = CONFIG.get('browser', 'unknown')
        default_label = Gtk.Label()
        default_label.set_markup(f"<b>Default:</b> {default_browser.title()}")
        sys_info_box.append(default_label)
        
        sys_info_frame.set_child(sys_info_box)
        content_box.append(sys_info_frame)

        search_frame = Gtk.Frame()
        search_frame.set_label_widget(Gtk.Label(label="<b>Search Apps</b>", use_markup=True))
        search_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        search_box.set_margin_top(12)
        search_box.set_margin_bottom(12)
        search_box.set_margin_start(12)
        search_box.set_margin_end(12)
        search_frame.set_child(search_box)
        
        self.search_entry = Gtk.Entry()
        self.search_entry.set_placeholder_text(_("Search apps..."))
        self.search_entry.connect("changed", self.on_search_changed)
        search_box.append(self.search_entry)
        content_box.append(search_frame)

        apps_frame = Gtk.Frame()
        apps_frame.set_label_widget(Gtk.Label(label="<b>PWA Selection</b>", use_markup=True))
        apps_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        apps_box.set_margin_top(12)
        apps_box.set_margin_bottom(12)
        apps_box.set_margin_start(12)
        apps_box.set_margin_end(12)
        apps_frame.set_child(apps_box)
        apps_box.append(Gtk.Label(label="Select App:", halign=Gtk.Align.START))
        
        factory = Gtk.SignalListItemFactory()
        factory.connect("setup", lambda f, item: item.set_child(Gtk.Label()))
        factory.connect("bind", lambda f, item: item.get_child().set_label(item.get_item().get_string()))
        
        self.app_combo = Gtk.DropDown(factory=factory)
        self.populate_app_combo()
        self.app_combo.connect("notify::selected", self.on_app_selected)
        apps_box.append(self.app_combo)
        content_box.append(apps_frame)

        options_frame = Gtk.Frame()
        options_frame.set_label_widget(Gtk.Label(label="<b>Options</b>", use_markup=True))
        options_grid = Gtk.Grid()
        options_grid.set_row_spacing(10)
        options_grid.set_column_spacing(12)
        options_grid.set_margin_top(12)
        options_grid.set_margin_bottom(12)
        options_grid.set_margin_start(12)
        options_grid.set_margin_end(12)
        options_frame.set_child(options_grid)

        options_grid.attach(Gtk.Label(label="URL:", halign=Gtk.Align.START), 0, 0, 1, 1)
        self.url_entry = Gtk.Entry()
        self.url_entry.set_hexpand(True)
        options_grid.attach(self.url_entry, 1, 0, 2, 1)

        self.kiosk_check = Gtk.CheckButton(label="Kiosk Mode")
        self.kiosk_check.set_active(CONFIG.get("kiosk", False))
        options_grid.attach(self.kiosk_check, 0, 1, 1, 1)

        self.gpu_check = Gtk.CheckButton(label="GPU Acceleration")
        self.gpu_check.set_active(CONFIG.get("gpu", True))
        options_grid.attach(self.gpu_check, 1, 1, 1, 1)

        self.gamepad_check = Gtk.CheckButton(label="WebHID Gamepad")
        self.gamepad_check.set_active(False)
        self.gamepad_check.set_tooltip_text("Enhanced WebHID for cloud gaming (Chromium browsers only)")
        options_grid.attach(self.gamepad_check, 2, 1, 1, 1)

        options_grid.attach(Gtk.Label(label="Browser:", halign=Gtk.Align.START), 0, 2, 1, 1)
        
        self.browser_model = Gio.ListStore.new(Gtk.StringObject)
        self.browser_combo = Gtk.DropDown.new(self.browser_model, None)
        self.refresh_browser_combo()
        self.browser_combo.connect("notify::selected", self.on_browser_changed)
        options_grid.attach(self.browser_combo, 1, 2, 2, 1)

        content_box.append(options_frame)

        ext_frame = Gtk.Frame()
        ext_frame.set_label_widget(Gtk.Label(label="<b>Extensions</b>", use_markup=True))
        ext_vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        ext_vbox.set_margin_top(12)
        ext_vbox.set_margin_bottom(12)
        ext_vbox.set_margin_start(12)
        ext_vbox.set_margin_end(12)
        ext_frame.set_child(ext_vbox)

        self.ext_scroll = Gtk.ScrolledWindow()
        self.ext_scroll.set_hexpand(True)
        self.ext_scroll.set_vexpand(True)
        self.ext_scroll.set_min_content_height(150)
        self.ext_listbox = Gtk.ListBox()
        self.ext_scroll.set_child(self.ext_listbox)
        ext_vbox.append(self.ext_scroll)

        ext_btn_box = Gtk.Box(spacing=6)
        self.install_preset_btn = Gtk.Button(label="Install Presets")
        self.install_preset_btn.connect("clicked", self.on_install_presets)
        self.open_store_btn = Gtk.Button(label="Open Store")
        self.open_store_btn.connect("clicked", self.on_open_store)
        self.add_custom_ext_btn = Gtk.Button(label="Add Custom")
        self.add_custom_ext_btn.connect("clicked", self.on_add_custom_ext)
        for b in [self.install_preset_btn, self.open_store_btn, self.add_custom_ext_btn]:
            ext_btn_box.append(b)
        ext_vbox.append(ext_btn_box)

        content_box.append(ext_frame)

        perf_frame = Gtk.Frame()
        perf_frame.set_label_widget(Gtk.Label(label="<b>Performance Tuning</b>", use_markup=True))
        perf_grid = Gtk.Grid()
        perf_grid.set_row_spacing(10)
        perf_grid.set_column_spacing(12)
        perf_grid.set_margin_top(12)
        perf_grid.set_margin_bottom(12)
        perf_grid.set_margin_start(12)
        perf_grid.set_margin_end(12)
        perf_frame.set_child(perf_grid)
        
        nice_label = Gtk.Label(label="Nice Priority:", halign=Gtk.Align.START)
        nice_label.set_tooltip_text("CPU scheduling priority (-20 to 19, lower = higher priority)")
        perf_grid.attach(nice_label, 0, 0, 1, 1)
        
        self.nice_spin = Gtk.SpinButton()
        self.nice_spin.set_range(-20, 19)
        self.nice_spin.set_increments(1, 5)
        self.nice_spin.set_value(CONFIG.get("nice", 0))
        perf_grid.attach(self.nice_spin, 1, 0, 1, 1)
        
        ionice_label = Gtk.Label(label="I/O Priority:", halign=Gtk.Align.START)
        ionice_label.set_tooltip_text("I/O scheduling class (0=none, 1=realtime, 2=best-effort, 3=idle)")
        perf_grid.attach(ionice_label, 0, 1, 1, 1)
        
        self.ionice_spin = Gtk.SpinButton()
        self.ionice_spin.set_range(0, 3)
        self.ionice_spin.set_increments(1, 1)
        self.ionice_spin.set_value(CONFIG.get("ionice", 2))
        perf_grid.attach(self.ionice_spin, 1, 1, 1, 1)
        content_box.append(perf_frame)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        btn_box.set_homogeneous(True)
        self.install_btn = Gtk.Button(label=_("Install"))
        self.install_btn.connect("clicked", self.on_install)
        self.install_custom_btn = Gtk.Button(label=_("Install Custom"))
        self.install_custom_btn.connect("clicked", self.on_install_custom)
        self.uninstall_btn = Gtk.Button(label=_("Uninstall"))
        self.uninstall_btn.connect("clicked", self.on_uninstall)
        self.clone_btn = Gtk.Button(label=_("Clone App"))
        self.clone_btn.connect("clicked", self.on_clone)
        self.refresh_btn = Gtk.Button(label=_("Refresh"))
        self.refresh_btn.connect("clicked", self.on_refresh)
        self.remove_btn = Gtk.Button(label=_("Delete App"))
        self.remove_btn.connect("clicked", self.on_remove_app)
        
        for b in [self.install_btn, self.install_custom_btn, self.uninstall_btn, self.clone_btn, self.refresh_btn, self.remove_btn]: 
            if b in [self.install_btn, self.install_custom_btn]:
                b.add_css_class("suggested-action")
            elif b in [self.uninstall_btn, self.remove_btn]:
                b.add_css_class("destructive-action")
            btn_box.append(b)
        content_box.append(btn_box)
        content_box.append(self.statusbar)

        self.update_banner = Adw.Banner()
        self.update_banner.set_title("Update Available")
        self.update_banner.set_button_label("View Releases")
        self.update_banner.connect(
            "button-clicked",
            lambda b: subprocess.run(["xdg-open", "https://github.com/bobbycomet/Appify/releases"])
        )
        self.update_banner.set_revealed(False)
        content_box.append(self.update_banner)

        def show_update_message(msg):
            if not msg:
                return
            version_line = msg.split("\n")[0]
            GLib.idle_add(self.update_banner.set_title, version_line)
            GLib.idle_add(self.update_banner.set_revealed, True)
            self.status_push(_("Update available!"))

        GLib.timeout_add_seconds(2, lambda: check_for_updates(show_update_message) or False)

        self.style_manager = Adw.StyleManager.get_default()
        self.apply_color_scheme()

        if self.sorted_apps_list:
            self.app_combo.set_selected(0)
            self.populate_app_fields(self.sorted_apps_list[0])
        self.update_button_states()

    def show_about_dialog(self, action=None, param=None):
        available = CONFIG.get('available_browsers', {})
        browser_list = '\n'.join([f"• {info['display_name']}" for info in available.values()])
        
        about = Adw.AboutDialog(
            application_name=_("Appify"),
            application_icon="appify",
            developer_name="BobbyComet",
            version=CURRENT_VERSION,
            website="https://github.com/bobbycomet/Appify",
            issue_url="https://github.com/bobbycomet/Appify/issues",
            license_type=Gtk.License.GPL_3_0,
            copyright=_("© 2025 BobbyComet"),
            comments=_(
                "Progressive Web Apps with Smart Detection\n\n"
                f"Session: {CONFIG.get('session_type', 'unknown').upper()}\n"
                f"Default Browser: {CONFIG.get('browser', 'none').title()}\n\n"
                f"Installed Browsers:\n{browser_list if browser_list else '• None detected'}"
            ),
            developers=["BobbyComet"],
        )
        about.add_link(_("Discord Community"), "https://discord.gg/7fEt5W7DPh")
        about.add_link(_("GitHub"), "https://github.com/bobbycomet/Appify")
        about.add_link(_("Support the project"), "https://ko-fi.com/bobby60908")

        SECURITY_POLICY = _(
        """Reporting a Vulnerability
        If you find a security issue, please do not open a public issue. Instead, please report it via:

        • Email: griffin.linux@gmail.com
        • Discord: https://discord.gg/7fEt5W7DPh

        Bounty Program
        As a solo developer, I do not currently offer financial bounties. However, I am happy to provide credit in the project's contributors list.

        How to Report
        1. Type of Issue: (e.g., Buffer overflow)
        2. Location: Which specific script or file?
        3. Step-by-Step Instructions: How to reproduce.
        4. Proof of Concept: Script or screenshot.
        5. Upstream Check: Does this exist in standard Ubuntu?""")

        about.add_legal_section(
            _("Security Policy"),
            SECURITY_POLICY,
            Gtk.License.UNKNOWN
        )
        about.present(self)

    def on_rescan_browsers(self, action=None, param=None):
        """Rescans for available browsers"""
        CONFIG["available_browsers"] = scan_available_browsers()
        CONFIG["browser"] = get_default_browser()
        save_config()
        self.refresh_browser_combo()
        
        browser_count = len(CONFIG['available_browsers'])
        self.status_push(_(f"Rescan complete: {browser_count} browser(s) found"))

    def on_restore_defaults(self, action=None, param=None):
        """Restores any missing default apps"""
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading="Restore Default Apps",
            body="This will restore any default apps that have been deleted.\n\nExisting apps will not be affected."
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("restore", "Restore")
        dialog.set_response_appearance("restore", Adw.ResponseAppearance.SUGGESTED)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "restore":
                restored_count = 0
                existing_names = {app["name"] for app in CONFIG["apps"].values()}
                
                for default_app in DEFAULT_APPS:
                    app_slug = slugify(default_app["name"])
                    # Only add if both the name and slug don't exist
                    if default_app["name"] not in existing_names and app_slug not in CONFIG["apps"]:
                        # Set browser to default if not specified
                        app_copy = default_app.copy()
                        if "browser" not in app_copy:
                            app_copy["browser"] = CONFIG["browser"]
                        CONFIG["apps"][app_slug] = app_copy
                        restored_count += 1
                
                if restored_count > 0:
                    save_config()
                    current_search = self.search_entry.get_text().strip()
                    self.populate_app_combo(current_search)
                    self.update_button_states()
                    self.status_push(f"Restored {restored_count} default app(s)")
                else:
                    self.status_push("All default apps are already present")
            dlg.close()
            
        dialog.connect("response", on_response)

    def get_selected_app(self):
        combo = self.app_combo
        selected_index = combo.get_selected()
        if selected_index >= 0 and selected_index < len(self.sorted_apps_list):
            return self.sorted_apps_list[selected_index]
        return None

    def apply_color_scheme(self):
        dark = CONFIG.get("dark_mode", True)
        self.style_manager.set_color_scheme(Adw.ColorScheme.FORCE_DARK if dark else Adw.ColorScheme.FORCE_LIGHT)
        self.mode_switch.set_active(dark)

    def on_mode_toggled(self, switch, _):
        dark = switch.get_active()
        CONFIG["dark_mode"] = dark
        save_config()
        self.apply_color_scheme()
        self.status_push(f"Switched to {'Dark' if dark else 'Light'} mode")

    def status_push(self, msg):
        GLib.idle_add(self.statusbar.set_text, msg)
        if hasattr(self, '_status_timeout_id') and self._status_timeout_id:
            GLib.source_remove(self._status_timeout_id)
        self._status_timeout_id = GLib.timeout_add_seconds(5, self._clear_status)

    def _clear_status(self):
        self.statusbar.set_text("")
        self._status_timeout_id = None
        return False  # Don't repeat

    def populate_app_combo(self, search_term=""):
        all_apps = CONFIG["apps"].values()
        
        if search_term:
            search_term_lower = search_term.lower()
            filtered_apps = [
                app for app in all_apps 
                if search_term_lower in app["name"].lower()
            ]
        else:
            filtered_apps = list(all_apps)
        
        self.sorted_apps_list = sorted(filtered_apps, key=lambda x: x["name"].lower())
        
        strings = []
        installed = set(list_installed_apps())
        
        for app in self.sorted_apps_list:
            name = app["name"]
            slug = slugify(name)
            text = f"✓ {name}" if slug in installed else name
            strings.append(text)
            
        model = Gio.ListStore.new(Gtk.StringObject)
        for s in strings:
            model.append(Gtk.StringObject.new(s))
        self.app_combo.set_model(model)

    def on_search_changed(self, entry):
        search_term = entry.get_text().strip()
        self.populate_app_combo(search_term)
        
        if self.sorted_apps_list:
            self.app_combo.set_selected(0)
            self.on_app_selected(self.app_combo, None) 
        else:
            self.app_combo.set_selected(Gtk.INVALID_LIST_POSITION)
            self.update_button_states()
            self.kiosk_check.set_active(False)
            self.gamepad_check.set_active(False)
            self.url_entry.set_text("")
            self.populate_extensions(None)

    def on_app_selected(self, combo, _):
        idx = combo.get_selected()
        if idx < 0 or idx >= len(self.sorted_apps_list):
            return
        app = self.sorted_apps_list[idx]
        self.populate_app_fields(app)
        self.populate_extensions(app)
        self.update_button_states()

    def populate_app_fields(self, app):
        self.url_entry.set_text(app.get("url", ""))
        self.kiosk_check.set_active(app.get("kiosk", False))
        self.gamepad_check.set_active(app.get("gamepad", False))
        
        profile_cfg = load_profile_config(app)
        browser_key = (profile_cfg.get("browser") or app.get("browser") or CONFIG.get("browser", "firefox")).lower()
        
        chromium_based = browser_key in ["edge", "brave", "vivaldi", "chrome", "chromium", "opera", "ungoogled-chromium"]
        self.gamepad_check.set_sensitive(chromium_based)
        if not chromium_based:
            self.gamepad_check.set_active(False)

        # Find browser in available list
        available_keys = list(CONFIG.get("available_browsers", {}).keys())
        try:
            idx = available_keys.index(browser_key)
            self.browser_combo.set_selected(idx)
        except ValueError:
            self.browser_combo.set_selected(0)

    def refresh_browser_combo(self):
        self.browser_model.remove_all()
        available = CONFIG.get("available_browsers", {})
        for key, info in available.items():
            self.browser_model.append(Gtk.StringObject.new(info['display_name']))

    def on_browser_changed(self, combo, _):
        idx = combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        
        available_keys = list(CONFIG.get("available_browsers", {}).keys())
        if idx < len(available_keys):
            browser_key = available_keys[idx]
            chromium_based = browser_key in ["edge", "brave", "vivaldi", "chrome", "chromium", "opera", "ungoogled-chromium"]
            self.gamepad_check.set_sensitive(chromium_based)
            if not chromium_based:
                self.gamepad_check.set_active(False)

    def populate_extensions(self, app):
        while True:
            row = self.ext_listbox.get_row_at_index(0)
            if row:
                self.ext_listbox.remove(row)
            else:
                break

        if not app:
            return

        installed_exts = load_installed_extensions(app)
        
        if not installed_exts:
            row = Gtk.ListBoxRow()
            lbl = Gtk.Label(label="No extensions installed")
            lbl.set_halign(Gtk.Align.START)
            lbl.set_margin_top(6)
            lbl.set_margin_bottom(6)
            lbl.set_margin_start(12)
            lbl.set_margin_end(12)
            row.set_child(lbl)
            self.ext_listbox.append(row)
        else:
            for ext in installed_exts:
                row = Gtk.ListBoxRow()
                box = Gtk.Box(spacing=12)
                box.set_margin_top(6)
                box.set_margin_bottom(6)
                box.set_margin_start(12)
                box.set_margin_end(12)
                lbl = Gtk.Label(label=ext.get("name", "Unknown"))
                lbl.set_halign(Gtk.Align.START)
                lbl.set_hexpand(True)
                box.append(lbl)
                btn = Gtk.Button(label="Remove")
                btn.add_css_class("destructive-action")
                btn.connect("clicked", lambda b, e=ext: self.on_remove_ext(app, e))
                box.append(btn)
                row.set_child(box)
                self.ext_listbox.append(row)

    def update_button_states(self):
        idx = self.app_combo.get_selected()
        valid = idx != Gtk.INVALID_LIST_POSITION and idx < len(self.sorted_apps_list)
        
        self.install_btn.set_sensitive(valid)
        self.uninstall_btn.set_sensitive(valid)
        self.clone_btn.set_sensitive(valid)
        self.remove_btn.set_sensitive(valid)
        self.install_preset_btn.set_sensitive(valid)
        self.open_store_btn.set_sensitive(valid)
        self.add_custom_ext_btn.set_sensitive(valid)

        if valid:
            app = self.sorted_apps_list[idx]
            slug = slugify(app["name"])
            installed = slug in list_installed_apps()
            self.install_btn.set_sensitive(not installed)
            self.uninstall_btn.set_sensitive(installed)

    def on_install_presets(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        app = self.sorted_apps_list[idx]
        available = get_available_presets(app)
        
        if not available:
            dialog = Adw.MessageDialog(
                transient_for=self,
                heading="No Presets Available",
                body=f"All available presets for {app['name']} are already installed."
            )
            dialog.add_response("ok", "OK")
            dialog.show()
            return
        
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading=f"Install Extension Presets for {app['name']}?",
            body=f"This will open your browser to install {len(available)} extension(s)."
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("install", "Install")
        dialog.set_response_appearance("install", Adw.ResponseAppearance.SUGGESTED)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "install":
                profile_cfg = load_profile_config(app)
                browser_key = (profile_cfg.get("browser") or app.get("browser") or CONFIG.get("browser", "firefox")).lower()
                preset_key = get_app_key(app)
                profile_dir = get_profile_dir(app)
                launch_extension_manager(browser_key, preset_key, profile_dir)
                
                installed_exts = load_installed_extensions(app)
                installed_exts.extend(available)
                save_installed_extensions(app, installed_exts)
                self.populate_extensions(app)
                self.status_push(f"Launched browser for extension installation")
            dlg.close()
            
        dialog.connect("response", on_response)

    def on_open_store(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        app = self.sorted_apps_list[idx]
        profile_cfg = load_profile_config(app)
        browser_key = (profile_cfg.get("browser") or app.get("browser") or CONFIG.get("browser", "firefox")).lower()
        browser_cfg = get_browsers().get(browser_key, {})
        store_url = browser_cfg.get("store_url", "https://chromewebstore.google.com/")
        subprocess.Popen(["xdg-open", store_url])
        self.status_push(_("Opened extension store"))

    def on_add_custom_ext(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        app = self.sorted_apps_list[idx]
        
        dialog = Adw.MessageDialog(transient_for=self, heading="Add Custom Extension")
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("add", "Add")
        dialog.set_response_appearance("add", Adw.ResponseAppearance.SUGGESTED)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8, margin_top=8, margin_bottom=8, margin_start=8, margin_end=8)
        box.append(Gtk.Label(label="Extension Name", halign=Gtk.Align.START))
        name_entry = Gtk.Entry()
        box.append(name_entry)
        box.append(Gtk.Label(label="Extension URL", halign=Gtk.Align.START))
        url_entry = Gtk.Entry()
        box.append(url_entry)
        dialog.set_extra_child(box)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "add":
                name = name_entry.get_text().strip()
                url = url_entry.get_text().strip()
                if name and url:
                    installed_exts = load_installed_extensions(app)
                    installed_exts.append({"name": name, "web_url": url})
                    save_installed_extensions(app, installed_exts)
                    self.populate_extensions(app)
                    self.status_push(f"Added custom extension: {name}")
            dlg.close()
            
        dialog.connect("response", on_response)

    def on_clone(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        app = self.sorted_apps_list[idx]
        
        dialog = Adw.MessageDialog(transient_for=self, heading=f"Clone {app['name']}")
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("clone", "Clone")
        dialog.set_response_appearance("clone", Adw.ResponseAppearance.SUGGESTED)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8, margin_top=8, margin_bottom=8, margin_start=8, margin_end=8)
        box.append(Gtk.Label(label="New App Name", halign=Gtk.Align.START))
        name_entry = Gtk.Entry()
        name_entry.set_text(f"{app['name']} (Clone)")
        box.append(name_entry)
        dialog.set_extra_child(box)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "clone":
                new_name = name_entry.get_text().strip()
                if new_name:
                    new_app = app.copy()
                    new_app["name"] = new_name
                    new_slug = slugify(new_name)
                    CONFIG["apps"][new_slug] = new_app
                    save_config()
                    self.populate_app_combo()
                    new_index = next((i for i, a in enumerate(self.sorted_apps_list) if a["name"] == new_name), 0)
                    self.app_combo.set_selected(new_index)
                    self.status_push(f"Cloned to {new_name}")
            dlg.close()
            
        dialog.connect("response", on_response)

    def on_install(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        app = self.sorted_apps_list[idx]
        self._perform_install(app)

    def on_install_custom(self, btn):
        url = self.url_entry.get_text().strip()
        if not url.startswith("http"):
            self.status_push("URL must start with http(s)://")
            return
        dialog = Adw.MessageDialog(transient_for=self, heading="Custom PWA")
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("install", "Install")
        dialog.set_response_appearance("install", Adw.ResponseAppearance.SUGGESTED)
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8, margin_top=8, margin_bottom=8, margin_start=8, margin_end=8)
        box.append(Gtk.Label(label="App Name", halign=Gtk.Align.START))
        name_entry = Gtk.Entry()
        inferred = urlparse(url).netloc.replace("www.", "").split('.')[0].capitalize()
        name_entry.set_text(inferred)
        box.append(name_entry)
        dialog.set_extra_child(box)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "install":
                name = name_entry.get_text().strip()
                if name:
                    available_keys = list(CONFIG.get("available_browsers", {}).keys())
                    selected_idx = self.browser_combo.get_selected()
                    browser_key_selected = available_keys[selected_idx] if selected_idx < len(available_keys) else CONFIG.get("browser", "firefox")

                    app = {
                        "name": name, 
                        "url": url, 
                        "kiosk": self.kiosk_check.get_active(),
                        "gamepad": self.gamepad_check.get_active() if self.gamepad_check.get_sensitive() else False,
                        "browser": browser_key_selected
                    }
                    app_slug = slugify(name)
                    CONFIG["apps"][app_slug] = app 
                    save_config()
                    self.populate_app_combo()
                    
                    new_index = next((i for i, a in enumerate(self.sorted_apps_list) if a["name"] == name), 0)
                    self.app_combo.set_selected(new_index)
                    
                    self._perform_install(app)
            dlg.close()
        dialog.connect("response", on_response)

    def _perform_install(self, app):
        kiosk = self.kiosk_check.get_active()
        gamepad = self.gamepad_check.get_active() if self.gamepad_check.get_sensitive() else False
        
        available_keys = list(CONFIG.get("available_browsers", {}).keys())
        selected_idx = self.browser_combo.get_selected()
        browser_key = available_keys[selected_idx] if selected_idx < len(available_keys) else CONFIG.get("browser", "firefox")

        gpu = self.gpu_check.get_active()
        CONFIG["gpu"] = gpu
        CONFIG["kiosk"] = kiosk
        CONFIG["nice"] = int(self.nice_spin.get_value())
        CONFIG["ionice"] = int(self.ionice_spin.get_value())
        
        app["kiosk"] = kiosk
        app["gamepad"] = gamepad
        app["browser"] = browser_key
        save_config()
        profile_cfg = load_profile_config(app)
        profile_cfg["browser"] = browser_key
        profile_cfg["gamepad"] = gamepad
        save_profile_config(app, profile_cfg)
        
        install_app(app, browser_key, kiosk, int(self.nice_spin.get_value()), int(self.ionice_spin.get_value()), gpu, self.status_push)
        
        self.populate_app_combo()
        self.update_button_states()

    def on_uninstall(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION:
            return
        
        app = self.sorted_apps_list[idx]
        uninstall_app(app["name"])
        self.status_push(f"Uninstalled {app['name']}")
        self.populate_app_combo()
        self.update_button_states()

    def on_refresh(self, btn):
        current_search = self.search_entry.get_text().strip()
        self.populate_app_combo(current_search)
        self.update_button_states()
        self.status_push(_("Refreshed"))

    def on_remove_app(self, btn):
        idx = self.app_combo.get_selected()
        if idx == Gtk.INVALID_LIST_POSITION or idx >= len(self.sorted_apps_list):
            return
        
        app = self.sorted_apps_list[idx] 
        app_name = app["name"]
        app_slug = slugify(app_name)
        
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading=f"Remove {app_name}?",
            body="Remove entry. Optionally delete profile."
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("keep", "Keep Profile")
        dialog.add_response("delete", "Delete Profile")
        dialog.set_response_appearance("delete", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.show()

        def on_response(dlg, resp):
            if resp == "cancel":
                dlg.close()
                return
            
            removed = CONFIG["apps"].pop(app_slug, None) 
            
            if removed:
                remove_app_files(removed)
            
            if resp == "delete":
                pd = get_profile_dir(app)
                try:
                    shutil.rmtree(pd)
                    self.status_push(f"Removed + profile deleted")
                except Exception as e:
                    self.status_push(f"Profile delete failed: {e}")
            else:
                self.status_push(f"Removed (profile kept)")
            
            save_config()
            current_search = self.search_entry.get_text().strip()
            self.populate_app_combo(current_search)
            self.update_button_states()
            dlg.close()
        dialog.connect("response", on_response)

    def on_remove_ext(self, app, ext):
        exts = load_installed_extensions(app)
        if ext in exts:
            exts.remove(ext)
            save_installed_extensions(app, exts)
        self.populate_extensions(app)

# ---------------- Main ----------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--launch-app", type=str)
    args = parser.parse_args()
    if args.launch_app:
        launch_app_from_cli(args.launch_app)
        return
    app = PWAManagerApp()
    app.run(sys.argv)

if __name__ == "__main__":
    script_path = Path(__file__)
    if not os.access(script_path, os.X_OK):
        try:
            script_path.chmod(0o755)
        except:
            pass
    main()
